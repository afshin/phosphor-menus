
/**
 * The class name added to collapsed separator nodes.
 */
const COLLAPSED_CLASS = 'p-mod-collapsed';


  /**
   * Activate the next selectable menu item.
   *
   * #### Notes
   * The search starts with the currently active item, and progresses
   * forward until the next selectable item is found. The search will
   * wrap around at the end of the menu.
   */
  activateNextItem(): void {
    let k = this.activeIndex + 1;
    let i = k >= this.items.length ? 0 : k;
    let pred = (item: MenuItem) => this.isSelectable(item);
    this.activeIndex = arrays.findIndex(this.items, pred, i, true);
  }

  /**
   * Activate the previous selectable menu item.
   *
   * #### Notes
   * The search starts with the currently active item, and progresses
   * backward until the next selectable item is found. The search will
   * wrap around at the front of the menu.
   */
  activatePreviousItem(): void {
    let k = this.activeIndex;
    let i = k <= 0 ? this.items.length - 1 : k - 1;
    let pred = (item: MenuItem) => this.isSelectable(item);
    this.activeIndex = arrays.rfindIndex(this.items, pred, i, true);
  }

  /**
   * Activate the next selectable menu item with the given mnemonic.
   *
   * #### Notes
   * The search starts with the currently active item, and progresses
   * forward until the next selectable item with the given mnemonic is
   * found. The search will wrap around at the end of the menu, and the
   * mnemonic matching is case-insensitive.
   */
  activateMnemonicItem(char: string): void {
    let c = char.toUpperCase();
    let k = this.activeIndex + 1;
    let i = k >= this.items.length ? 0 : k;
    this.activeIndex = arrays.findIndex(this.items, item => {
      if (!this.isSelectable(item)) {
        return false;
      }
      let match = item.text.match(/&\w/);
      if (!match) {
        return false;
      }
      return match[0][1].toUpperCase() === c;
    }, i, true);
  }
/**
 *
 */
export
namespace MenuBase {
  /**
   * Collapse leading, trailing, and consecutive separators.
   *
   * @param items - The array of menu items of interest. This should be
   *   the same length as the `nodes` array.
   *
   * @param nodes - The nodes representing the menu items. This should be
   *   the same length as the `items` array.
   */
  export
  function collapseSeparators(items: MenuItem[], nodes: HTMLElement[]): void {
    // Collapse the leading separators.
    let k1: number;
    for (k1 = 0; k1 < items.length; ++k1) {
      let item = items[k1];
      let node = nodes[k1];
      if (item.type !== MenuItem.Separator) {
        node.classList.remove(COLLAPSED_CLASS);
        break;
      }
      node.classList.add(COLLAPSED_CLASS);
    }

    // Collapse the trailing separators.
    let k2: number;
    for (k2 = items.length - 1; k2 >= 0; --k2) {
      let item = items[k2];
      let node = nodes[k2];
      if (item.type !== MenuItem.Separator) {
        node.classList.remove(COLLAPSED_CLASS);
        break;
      }
      node.classList.add(COLLAPSED_CLASS);
    }

    // Collapse the remaining consecutive separators.
    let collapse = false;
    while (++k1 < k2) {
      let item = items[k1];
      let node = nodes[k1];
      if (collapse && item.type === MenuItem.Separator) {
        node.classList.add(COLLAPSED_CLASS);
      } else {
        node.classList.remove(COLLAPSED_CLASS);
        collapse = item.type === MenuItem.Separator;
      }
    }
  }
}


  /**
   * A method invoked when a menu item should be opened.
   */
  protected onOpenItem(index: number, item: MenuItem): void {
    if (this.isAttached && item.submenu) {
      let ref = this._nodes[index] || this.node;
      this._activate();
      this._closeChildMenu();
      this._openChildMenu(item.submenu, ref);
    }
  }




  /**
   * Handle the `'mousedown'` event for the menu bar.
   */
  private _evtMouseDown(event: MouseEvent): void {
    let x = event.clientX;
    let y = event.clientY;

    // If the bar is active and the mouse press is on an open menu,
    // let that menu handle the press. The bar will reset when the
    // menu emits its `closed` signal.
    if (this._active && hitTestMenus(this._childMenu, x, y)) {
      return;
    }

    // Check if the mouse was pressed on one of the menu items.
    let i = hitTestNodes(this._nodes, x, y);

    // If the bar is active, deactivate it and close the child menu.
    // The active index is updated to reflect the mouse press, which
    // is either valid, or `-1`.
    if (this._active) {
      this._deactivate();
      this._closeChildMenu();
      this.activeIndex = i;
      return;
    }

    // At this point, the bar is not active. If the mouse press
    // was not on a menu item, clear the active index and return.
    if (i === -1) {
      this.activeIndex = -1;
      return;
    }

    // Otherwise, the press was on a menu item. Activate the bar,
    // update the active index, and open the menu item if possible.
    this._activate();
    this.activeIndex = i;
    this.openActiveItem();
  }



  /**
   * Handle the `'mousemove'` event for the menu bar.
   */
  private _evtMouseMove(event: MouseEvent): void {
    let x = event.clientX;
    let y = event.clientY;

    // Check if the mouse is over one of the menu items.
    let i = hitTestNodes(this._nodes, x, y);

    // Bail early if the active index will not change.
    if (i === this.activeIndex) {
      return;
    }

    // Bail early if the bar is active and the mouse is not over an
    // item. This allows the leading and trailing menus to be kept
    // open when the mouse is over the empty part of the menu bar.
    if (i === -1 && this._active) {
      return;
    }

    // Update the active index to the hovered item.
    this.activeIndex = i;

    // If the bar is not active, there's nothing more to do.
    if (!this._active) {
      return;
    }

    // Otherwise, close the current child menu and open the new one.
    this._closeChildMenu();
    this.openActiveItem();
  }

  /**
   * Handle the `'mouseleave'` event for the menu bar.
   */
  private _evtMouseLeave(event: MouseEvent): void {
    if (!this._active) this.activeIndex = -1;
  }

  /**
   * Handle the `'keydown'` event for the menu bar.
   */
  private _evtKeyDown(event: KeyboardEvent): void {
    event.stopPropagation();
    let menu = this._childMenu;
    let leaf = menu && menu.leafMenu;
    switch (event.keyCode) {
    case 13:  // Enter
      event.preventDefault();
      if (leaf) leaf.triggerActiveItem();
      break;
    case 27:  // Escape
      event.preventDefault();
      if (leaf) leaf.close();
      break;
    case 37:  // Left Arrow
      event.preventDefault();
      if (leaf && leaf !== menu) {
        leaf.close();
      } else {
        this._closeChildMenu();
        this.activatePreviousItem();
        this.openActiveItem();
      }
      break;
    case 38:  // Up Arrow
      event.preventDefault();
      if (leaf) leaf.activatePreviousItem();
      break;
    case 39:  // Right Arrow
      event.preventDefault();
      if (leaf && activeHasMenu(leaf)) {
        leaf.openActiveItem();
      } else {
        this._closeChildMenu();
        this.activateNextItem();
        this.openActiveItem();
      }
      break;
    case 40:  // Down Arrow
      event.preventDefault();
      if (leaf) leaf.activateNextItem();
      break;
    }
  }

  /**
   * Handle the `'keypress'` event for the menu bar.
   */
  private _evtKeyPress(event: KeyboardEvent): void {
    event.preventDefault();
    event.stopPropagation();
    let menu = this._childMenu;
    let leaf = menu && menu.leafMenu;
    let key = String.fromCharCode(event.charCode);
    (leaf || this).activateMnemonicItem(key);
  }

  /**
   * Open the child menu using the given item node for location.
   */
  private _openChildMenu(menu: Menu, node: HTMLElement): void {
    let rect = node.getBoundingClientRect();
    this._childMenu = menu;
    menu.addClass(MENU_CLASS);
    menu.open(rect.left, rect.bottom, false, true);
    menu.closed.connect(this._onMenuClosed, this);
  }

  /**
   * Close the current child menu, if one exists.
   */
  private _closeChildMenu(): void {
    let menu = this._childMenu;
    if (menu) {
      this._childMenu = null;
      menu.closed.disconnect(this._onMenuClosed, this);
      menu.removeClass(MENU_CLASS);
      menu.close();
    }
  }

  /**
   * Activate the menu bar and switch the mouse listeners to global.
   *
   * The listeners are switched after the current event dispatch is
   * complete. Otherwise, duplicate event notifications could occur.
   */
  private _activate(): void {
    if (this._active) {
      return;
    }
    this._active = true;
    this.addClass(ACTIVE_CLASS);
    setTimeout(() => {
      this.node.removeEventListener('mousedown', this);
      document.addEventListener('mousedown', this, true);
      document.addEventListener('keydown', this, true);
      document.addEventListener('keypress', this, true);
    }, 0);
  }

  /**
   * Deactivate the menu bar switch the mouse listeners to local.
   *
   * The listeners are switched after the current event dispatch is
   * complete. Otherwise, duplicate event notifications could occur.
   */
  private _deactivate(): void {
    if (!this._active) {
      return;
    }
    this._active = false;
    this.removeClass(ACTIVE_CLASS);
    setTimeout(() => {
      this.node.addEventListener('mousedown', this);
      document.removeEventListener('mousedown', this, true);
      document.removeEventListener('keydown', this, true);
      document.removeEventListener('keypress', this, true);
    }, 0);
  }

  /**
   * Reset the menu bar to its default state.
   */
  private _reset(): void {
    this._deactivate();
    this._closeChildMenu();
    this.activeIndex = -1;
  }

  /**
   * Handle the `changed` signal from a menu item.
   */
  private _onItemChanged(sender: MenuItem, args: IChangedArgs<any>): void {
    this._reset();
    this.update();
  }

  /**
   * Handle the `closed` signal from the child menu.
   */
  private _onMenuClosed(sender: Menu): void {
    sender.closed.disconnect(this._onMenuClosed, this);
    sender.removeClass(MENU_CLASS);
    this._childMenu = null;
    this._reset();
  }
let emptyItems: MenuItem[] = Object.freeze([]);

/**
 * Create an uninitialized DOM node for a MenuItem.
 */
function createItemNode(): HTMLElement {
  let node = document.createElement('li');
  let icon = document.createElement('span');
  let text = document.createElement('span');
  text.className = TEXT_CLASS;
  node.appendChild(icon);
  node.appendChild(text);
  return node;
}


/**
 * Create the complete DOM node class name for a MenuItem.
 */
function createItemClass(item: MenuItem): string {
  let parts = [ITEM_CLASS];
  if (item.className) {
    parts.push(item.className);
  }
  if (item.type === MenuItem.Separator) {
    parts.push(SEPARATOR_TYPE_CLASS);
  } else if (item.type !== MenuItem.Submenu) {
    parts.push(HIDDEN_CLASS);
  } else if (!item.submenu) {
    parts.push(DISABLED_CLASS);
  }
  return parts.join(' ');
}


/**
 * Create the icon node class name for a MenuItem.
 */
function createIconClass(item: MenuItem): string {
  return item.icon ? (ICON_CLASS + ' ' + item.icon) : ICON_CLASS;
}


/**
 * Create the text node content for a MenuItem.
 */
function createTextContent(item: MenuItem): string {
  let sep = item.type === MenuItem.Separator;
  return sep ? '' : item.text.replace(/&/g, '');
}


/**
 * Update the node state for a MenuItem.
 */
function updateItemNode(item: MenuItem, node: HTMLElement): void {
  let icon = node.firstChild as HTMLElement;
  let text = node.lastChild as HTMLElement;
  node.className = createItemClass(item);
  icon.className = createIconClass(item);
  text.textContent = createTextContent(item);
}


/**
 * Test whether a menu's active item has a submenu.
 */
function activeHasMenu(menu: Menu): boolean {
  let item = menu.items[menu.activeIndex];
  return !!(item && item.submenu);
}


/**
 * Get the index of the node at a client position, or `-1`.
 */
function hitTestNodes(nodes: HTMLElement[], x: number, y: number): number {
  for (let i = 0, n = nodes.length; i < n; ++i) {
    if (hitTest(nodes[i], x, y)) return i;
  }
  return -1;
}


/**
 * Hit test the chain menus for the given client position.
 */
function hitTestMenus(menu: Menu, x: number, y: number): boolean {
  while (menu) {
    if (hitTest(menu.node, x, y)) {
      return true;
    }
    menu = menu.childMenu;
  }
  return false;
}
